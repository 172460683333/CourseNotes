# JVM

#### JVM，JRE, JDK 的区别

JDK：java development kit  java 开发工具包，包含了JRE，java工具（如编译器，调试器）， javaAPI。

JRE：java runtime environment java运行环境，包含了JVM，java  application launcher，runtime class libraries等一些核心类库，java开发者通过JRE将自己的程序发布到用户手中。

JVM：java virtual machine java虚拟机，一台虚构的用来模拟计算机各种功能的机器。JVM是java实现跨平台运行的核心，负责解释执行字节码文件，所有平台上的JVM向编译器提供相同的接口，编译器只需要面向虚拟机，提供虚拟机可以识别的字节码。

#### Java的跨平台原理？如何实现“一次编写，多处运行”？

当使用Java编译器编译Java程序时，生成的是与平台无关的字节码，这些字节码只面向JVM。不同平台的JVM都是不同的，但它们都提供了相同的接口。JVM是Java程序跨平台的关键部分，只要为不同平台实现了相应的虚拟机，编译后的Java字节码就可以在该平台上运行。

#### JVM的体系结构

JVM包括方法区,虚拟机栈,本地方法栈,堆和程序计数器

##### 方法区

- 储存静态变量，常量，类信息（类的名称，方法信息，字段信息）
- 储存运行时常量池
- 储存编译器编译后的代码
- 多线程共享

##### 常量池

1. Class常量池和运行时常量池
   - class常量池是Class文件中的资源仓库,,用于存放class文件中的字面量和符号引用
   - 字面量是字符组成的常量,符号引用是类和接口的全限定名,以及字段,方法的名称和描述符
   - 常量池装入内存后称为运行时常量池
2. 字符串常量池
   - JVM为提高效率,单独给字符串开辟的常量池,储存在元空间中
   - 创建字符串时先检查字符串常量池是否有该字符串,没有则实例化字符串并加入常量池,反之直接返回该字符串.

##### 栈

储存基本数据类型和引用数据类型首地址（即对象的引用），线程独有

栈帧：随着一个方法的调用开始而创建并入栈，这个方法调用完成后弹出并销毁。栈帧包含局部变量表，操作数栈，运行时常量池的引用，方法返回地址，附加信息。

栈内存的大小可以有两种设置，固定值和根据线程需要动态增长。

StackOverflowError：栈内存为固定值时，程序运行需要的栈内存超过限定大小

OutOfMemoryError ：栈内存设置成动态增长时，需要的栈内存大小超过了JVM可用内存

##### 堆

储存对象实例，多线程共享

JVM启动时就会创建堆内存，内存空间动态分配，但存取速度较慢，具有垃圾回收机制。

##### 本地方法栈

管理本地方法的调用，线程私有。

在HotSopt虚拟机中本地方法栈和Java栈合二为一了

##### JVM知识体系&架构图传送门

[JVM 知识导图_processon](https://www.processon.com/mindmap/621321e11efad406e739451b)  [JVM 架构图_processon](https://www.processon.com/mindmap/6213293b1e08533f90c5b520)

#### 类加载器ClassLoader

作用：加载.class文件

分类：

1. 虚拟机自带的加载器
2. 启动类（根）加载器**Bootstrap classLoader**: 主要负责加载核心的类库(java.lang.*等)，构造扩展加载器ExtClassLoader和应用程序APPClassLoader。
3. 扩展类加载器**ExtClassLoader**：主要负责加载jre/lib/ext目录下的一些扩展的jar包          //class.getClassLoader().getParent()
4. 应用程序加载器**AppClassLoader**：主要负责加载应用程序的主函数类   //class.getClassLoader() , rt.jar

类加载器，类，对象的关系：

![image-20220222124751085](C:/Users/17246/AppData/Roaming/Typora/typora-user-images/image-20220222124751085.png)

#### 类加载内存分析

- 类在加载到内存之前，会经历加载，链接，初始化三个过程。
- 加载阶段将字节码文件的读入内存，将静态数据转换为方法区的运行时数据结构，并创建Class对象，由类加载器完成。
- 链接是将一些二进制文件合并到JRE中，分为三个过程，验证（检查语法错误），准备（为static变量分配内存，并为类的变量赋默认值），解析（将常量池中的符号引用【变量名】替换为直接引用【地址】）。
- 初始化是执行类构造器**<clinit>()**方法构造类的信息的过程，**<clinit>()**是编译器收集所有类的变量赋值和静态代码块中的语句产生的。如果父类的**<clinit>()**没被调用，会先调用父类的**<clinit>()**方法；JVM保证其线程安全。

#### 双亲委派机制

双亲委派机制下的类加载流程：

​	1.首先应用加载器会判断目标类是否被加载过，如果没有就向上委托给父级加载器即扩展类加载器

​	2.重复过程1直至根加载器

​	3.根加载器会检查自己是否可以加载此类，如果可以就加载，不能的话就丢给子级加载器

​	4.重复过程2直至应用加载器，如果还是无法加载就会抛出ClassNotFoundException。

![image-20220222143342103](C:/Users/17246/AppData/Roaming/Typora/typora-user-images/image-20220222143342103.png)

*图中序号为所有加载器都无法加载该类抛出ClassNotFoundException时的执行流程

双亲委派机制的好处: 保护底层文件，防止用户随意定义java自带的类。 例如当用户创建java.lang.String 并尝试加载时，根加载器会先加载rt.jar中的java.lang.String，而不会等到应用加载器加载用户自定义的String类。

#### 沙箱安全机制

通过限制程序运行环境来保护本地系统。

沙箱即一个个限定资源访问的域,代码在该域中运行不会影响外部环境.

#### native关键字

java解决不了的问题，需要调用底层c语言的库

执行带native的方法时，程序会进入本地方法栈，调用本地方法接口JNI，这样可以调用一些其他语言的库，如c，c++，python等语言的库。

#### 堆详解

堆分为新生区，老年区，永久区(Jdk8以后,永久区被元空间取代)

对象在伊甸园区创建，伊甸园区满后触发轻量级垃圾回收，存活下来的对象进入幸存区，幸存区和伊甸园区满后触发重量级垃圾回收，存活下来的类进入养老区。

永久区/元空间：常驻内存，储存java运行环境，不存在垃圾回收，关闭虚拟机时释放内存。

##### 堆内存调优参数

-Xms ：设置初始分配大小，默认为物理内存的 “1/64”。
-Xmx ：最大分配内存，默认为物理内存的 “1/4”。
-XX:+PrintGCDetails ：输出详细的GC处理日志。

JProfiler插件用于查看对象内存占用

#### GC

轻量级GC

重量级full-GC

常用的GC算法：标记清除法，标记压缩法，复制算法，引用计数法

引用计数法：给每个对象添加一个引用次数,引用时+1,引用失效-1，效率低下且循环引用会产生内存泄漏，java未采用

标记清除法（老年区）：扫一遍，标记不可达对象，再扫一遍，清除被标记的对象

标记压缩法（老年区）：扫一遍，移动活动对象，清除内存碎片

复制算法（新生代）：幸存区分为from和to两个空间，当from空间被占满时，GC会把活动对象全部复制到to空间,清楚不可达对象。当复制完成后，From 空间和 To 空间互换，GC 也就结束了。From 空间和 To 空间大小必须一致。15次轻GC后，幸存区存活下来的对象就会进入老年区。

好处:

- 吞吐量优秀
- 可实现告诉分配：分配内存的时候在末尾累加就行了
- 没有碎片化问题
- 与缓存兼容：有引用关系的内存间距离很近，一般都是挨着的

缺点：

浪费了to区空间,堆内存利用率低

