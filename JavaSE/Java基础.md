# Java基础

### 面向对象

#### 什么是面向对象，面向对象和面向过程的区别是什么

面向过程--步骤化

面向过程是分析实现需求的步骤，通过函数或方法依次实现这些步骤

面向对象--行为化

面向对象是指把整个需求按照特点，功能将存在共性的部分抽象成一个类，类实例化得到对象，创建对象的目的不是完成某个步骤，而是描述某个事物在一个步骤中的行为和特征。

区别：面向过程关注需求实现的步骤，面向对象更关注需求中事物的行为特征，在大型项目中代码逻辑更清晰，优势明显。

#### java面向对象有哪些特征

面向对象的三大特征：封装，继承，多态

##### 封装

java可以将事物的共性抽象成类的属性和方法，再通过对属性和方法的封装来隐藏该类实现的细节。例如我们只需要知道狗会叫，但是不需要知道狗是如何控制肌肉，声带来发出吠叫声的。

##### 继承

子类可以继承父类的属性和方法并加以扩展，增加了代码的可复用性。例如动物有有基本生命体征，能呼吸，能运动，可以繁殖后代等，狗子也有这些特征，但是狗子也有一些特有的特征，比如会狗叫，忠诚，是人类的好盆友等等。狗子类继承动物类并且附加狗叫，忠诚等属性可以减少重复代码的书写。

##### 多态

同一个父类的不同子类可以有不同的表现, 例如鸡和狗都继承动物类，但鸡会下蛋，狗会看门。

### 基础知识&语法

#### 数据类型

Java的数据类型包括基本数据类型和引用数据类型，基本数据类型包括整型（byte，short，int，long），浮点类型（float，double），char类型，boolean类型，引用数据类型包括类，接口，数组.

##### int和Integer

- Integer是int的包装类；int是基本数据类型；
- Integer变量必须实例化后才能使用；int变量不需要；
- Integer是引用数据类型，指向此new的Integer对象；int数据储存在常量池中
- Integer的默认值是null；int的默认值是0。
- **在-128~127之内的数值，它们被装箱为Integer对象后，会存在内存中被重用(因为数值存在常量池并会缓存)，始终只存在一个对象**。
- *享元模式

```java
//成员变量 int a = 1;a 存放在方法区，1存放在堆内存，a指向该内存
//局部变量 int a = 1;a 存放在方法区， 1存放在栈内存，a指向该变量
//Integer a = 1; a存放在方法区,1在常量池(-128~127)
//Integer a = 128; a存放在方法区,128在堆中
```

#### String

string是不可变对象,用双引号包围的字符串都储存在方法区中的常量池里来提高运行效率

#### **String、StringBuilder、StringBuffer的区别**

- String ,String Builder,StringBuffer类都使用了final修饰，不能被继承.

- String是不可变字符串,每次对字符串的修改都是新建了一个字符串,效率低下.

- stringBuffer和stringBuilder都属于可变字符串，字符串改变不会重新创建一个新的字符串.

- StringBuffer 是线程安全的，StringBuilder为非线程安全.

- StringBuffer 使用 synchronized，会进行同步，效率没有StringBuilder快.

#### 接口和抽象类的特点和区别

1. 抽象类可以有构造方法，接口没有
2. 抽象类可以有抽象方法和具体方法，接口只能有抽象方法
3. 抽象类的成员变量和普通类一样，接口只能有public static final的成员变量
4. 有抽象方法的类必须声明为抽象类
5. 抽象类可以有静态方法，接口不能有
6. 接口可以多继承
7. 抽象类倾向于表达一种概念，例如狗是一种动物，接口倾向于表达一种特征，例如狗能吠，跑，舔。

#### 重写和重载的区别

1. 重载和重写都是多态的表现形式，重载实现了编译时的多态，重写实现了运行时的多态。
2. 重载发生在同一个类中，同名方法拥有不同的参数列表（参数的类型，数量不同）而同时存在就称为重载，重载对返回值没有要求
3. 重写发生在子类和父类之间，子类重写方法的名称和参数列表必须和父类相同，有兼容的返回类型，访问权限不能小于父类，不能声明更多的异常。

#### static

static可以修饰变量和方法,也可以修饰一段代码块

变量,方法或者代码块static修饰后,在类被加载时就会被分配和载入内存. 否则会在类对象被创建时才会被载入对象的内存。

静态变量和方法属于类,不属于对象

#### final

final可以修饰类,变量,数据,表示不可改变,被final修饰的类不可被继承,因此final不能修饰抽象类和接口

#### abstract

abstract可以修饰类和方法,抽象方法只能存在于抽象类,不能被final和static修饰.

### 