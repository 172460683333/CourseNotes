# 多线程

## 概念

进程

- 进程是程序运行的实例, 资源分配的基本单元

线程

- 线程是程序的执行路径,程序执行的基本单位
- 一个进程可以包含一个或多个线程.
- 线程开启后不一定立即执行,由CPU安排调度.

多线程

- 多个线程同时执行

超线程

- 一个ALU可以对应两组寄存器,即一个CPU可以完成两个线程

## 线程

### 线程的状态

创建,就绪,运行,阻塞,死亡

阻塞不能直接运行,需要先进入就绪态

### 线程的创建

#### 继承Thread类

1. 自定义线程类继承Thread类
2. 重写run()方法,编写线程执行体
3. 创建线程对象,调用start方法,start方法不能连续执行
4. 优点:简单

#### 实现runnable接口

1. 创建runnable接口的实现类
2. 重写run()方法,编写线程执行体
3. 创建线程对象,传入runnable接口的实现类,调用start方法
4. 优点:类可以实现多个接口

#### 实现callable接口

1. 创建callable接口的实现类,重写call()方法,方法有返回值且能抛异常
2. FutureTask类包装callable的实例对象,用于接收运算结果
3. 用FutureTask的Result.get()方法接收运算结果,此方法会在所用线程执行完毕后执行
4. 优点:call()方法有返回值且能抛异常

### 守护线程

守护线程即操作系统的内核线程,Java中用户线程和内核线程采用1对1模型

JVM不会等守护线程结束，会等用户线程结束

通过setDaemon（）方法设置守护线程

线程一般默认是用户线程，守护线程主要有GC线程，后台记录操作日志，监控内存等

## 死锁

### 死锁发生的条件

1. 互斥：一个资源只能被一个线程使用，即该资源被加锁
2. 占有且等待：线程在等待请求的资源而阻塞时，不会释放已获得的资源
3. 不剥夺：线程已获得的资源不会被强行剥夺
4. 循环等待：若干个线程形成一种循环等待的关系

### 避免死锁产生的方法

一般死锁一旦反生,很难人为解除,可以通过一些措施预防死锁,即破坏死锁发生的条件

- 互斥条件不可破坏,因为线程本身就是互斥的
- 破坏请求与等待: 一次性分配线程所需的全部资资源

- 破坏不剥夺条件:线程如果长期不能获得请求的资源时,自动放弃请求释放资源,代码层面可以使用Lock类的tryLock方法设置超时时间
- 破坏循环等待条件:给系统资源编号,分配资源时按顺序分配.
- 编程习惯上尽量使用并发工具类代替加锁，显式加锁与释放更为清晰,减少同步的代码块

## CAS

compare and swap在不加锁的前提下,多个线程操作同一个数据

<img src="C:\Users\lsw\AppData\Roaming\Typora\typora-user-images\image-20230203213843838.png" alt="image-20230203213843838" style="zoom: 33%;" />

线程在修改一个值之前需要先比较该值是否与读取时的值一致,若一致,写入,否则重新读取. 在比较完到写入的过程中,java调用本地方法中用cpp实现的lock cmxchg方法(compare and exchange),该方法在硬件层面保证了只有一个线程可以修改该数据,其中lock起到关键作用

#### ABA问题

线程甲读取数据A再写入的过程中,多个其他线程修改了数据,但最终的结果还是A,线程甲并不知道A的数据被改动过,可能产生问题.

解决办法:加一个版本号,每次改动更新版本号,写入前比较数值和版本号.

## synchronized

早期synchronized直接申请重量级锁,现在是一个逐步升级的过程

### 锁的升级

无锁态(new)-->偏向锁-->轻量级锁-->重量级锁

- 偏向锁：资源加锁后,第一个访问该资源的线程会给该线程打上自己线程id的标签,即偏向锁,不做任何实际限制
- 轻量级锁(自旋锁)：任意一个其他线程访问该资源，偏向锁就会升级为轻量级锁，每个竞争线程的线程栈会生成一个lock record指针,竞争过程为每个线程对该资源进行CAS操作,操作成功的线程资源访问权限

  - 自旋:竞争失败的线程不会阻塞,而是不断循环尝试获取该资源,
  - 优点:减少线程调度和切换的次数
  - 缺点:循环本身消耗CPU资源
- 重量级锁：某个线程自旋达到一定次数,轻量级锁升级为重量级锁,jdk6以前为自旋10次,jdk6以后改为自适应自旋,由jvm决定自旋次数.重量级锁是操作系统内核态的互斥量,未获得该资源访问权限的线程将被阻塞.

​		--GC时锁进行降级(不用管)

锁的消除:如果JVM发现某资源不可能被其他线程访问,会自动把锁消除

锁的粗化:如果连续对某一个资源加锁解锁,JVM会只在整个过程中加一次锁

## volatile

volatile可以保证变量的可见性和代码的有序性，是最轻量级的同步机制，但是不能保证线程安全。

### volatile同步机制

volatile同步机制的实现如下:

1. 字节码层面:添加ACC_VOLATILE标签,告知JVM此处使用了volatile关键字
2. JVM通过内存屏障实现禁止指令重排序
3. CPU层面通过MESI协议和总线嗅探机制实现线程可见性

*volatile并不能保证线程安全,因为java运算不是原子操作，一个处理器在执行某一段代码的过程中可能会执行其他线程的代码

### 线程可见性

线程在修改数据时会将数据从堆中复制到本线程的空间中,操作完后在写回到堆里.线程本地内存其他线程不可见,使用Volatile关键字后,该数据将对所有线程可见.

#### MESI协议

CPU保持数据一致性的基本单位是缓存行cache line,大小为64字节.

频繁访问的数据处于独占状态下效率高,因此常采用前后填充数据以提升效率的方式称为缓存行对齐(占满64字节).

MESI协议规定缓存行的四种状态

- **M**odify（修改）：当缓存行中的数据被修改时，该缓存行置为M状态
- **E**xclusive（独占）：当只有一个缓存行使用某个数据时，置为E状态
- **S**hared（共享）：当其他CPU中也读取某数据到缓存行时，所有持有该数据的缓存行置为S状态
- **I**nvalid（无效）：当某个缓存行数据修改时，其他持有该数据的缓存行置为I状态

英特尔CPU使用**MESI协议**保持数据缓存一致性.

#### 总线嗅探机制

如果两个CPU的某个缓存行都含有同一个数据a,当CPU1中的a修改时,CPU2再次读取a是缓存行状态已经变成了I(非法),这样CPU2会重新到主存中读取该数据.

volatile就是通过MESI协议和总线嗅探机制来实现数据的线程可见性的

### 禁止指令重排序

JVM利用内存屏障实现指令的有序执行,读操作前使用loadload型屏障,读操作后使用loadstore型屏障,写操作前使用storestore型屏障,写操作后使用storeload型屏障

## ReentrantLock

ReentrantLock是JUC中定义的一种显示锁，实现了Lock接口，需要手动释放锁

#### AQS

- 利用内部类Node维护了一个队列
- state: state=1表示线程竞争锁成功

#### lock()

ReentrantLock.lock()有两种实现方式,通过sync参数控制,默认使用非公平:

	1. FairSync 公平锁,每个线程执行lock方法时,会先查看是否有线程排队,有则加入队尾,无则尝试竞争锁资源
	1. NofairSync非公平锁,每个线程执行lock方法时,会直接尝试获取资源,获取不到再排队

竞争锁资源即线程以CAS的方式尝试将AQS的state改成1

公平锁:直接调用acquire()方法

非公平锁:先用基于CAS的方式尝试获取锁资源,获取不到再调用acquire()

#### acquire()

公平锁:如果state为0,查看是否有线程排队,无人排队获取锁,state为1,看看是不是自己,是自己就锁重入

非公平锁:如果state为0,尝试CAS修改.state为1,看看是不是自己,是自己就锁重入

#### 线程的同步，锁

通过队列和加锁可以在一定程度上解决并发问题

synchronized，当一个线程拥有排它锁时，独占资源，其他线程必须等待，这样也会引起其它问题，如：

- 一个线程持有锁会导致其他需要此锁的线程挂起
- 多线程竞争下，加锁，释放锁，会产生多次的上下文切换和调度延迟
- 一个高优先级线程需要等待一个低优先级线程释放锁，导致优先级倒置

ReentrantLock ，实现Lock接口，JUC中定义的一种显示锁，在性能上比synchronized好，需要手动释放锁

ReadWriteLock也实现了Lock接口，适用于文件的读写操作



##### 锁的类型

- 公平锁/非公平锁：公平锁按锁的申请顺序分配锁，非公平锁不关心申请顺序，synchronized是非公平锁，reentrantLock默认是非公平锁，但是可以设置成公平锁
- 可重入锁：可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁。ReentrantLock 和synchronized都是可重入锁
- 独享锁/共享锁：顾名思义，独享锁是一个线程独有的锁，ReadWriteLock中写锁是独享锁，读锁是共享锁，ReentrantLock，synchronized是独享锁
- 乐观锁/悲观锁：乐观锁在操作数据时非常乐观，认为别人不会同时修改数据。. 因此乐观锁不会上锁，只是在执行更新的时候判断一下在此期间别人是否修改了数据：如果别人修改了数据则放弃操作，否则执行操作。悲观锁相反。ReentrantLock，synchronized都是悲观锁。

#### 线程池

线程池使用了池化思想,java中的池有:线程池,字符串常量池,数据库连接池,目的是提高资源利用率,提升执行效率

线程池是一种线程的使用模式，用于存放和管理线程。创建线程后，缓存到线程池中，下次使用时再调用.

优点:

- 提高线程利用率
- 降低线程创建和销毁的开销,提高程序执行效率
- 便于统一管理线程对象
- 利用线程池参数控制系统并发度

##### **线程池流程**

- 判断核心线程池是否已满，即已创建线程数是否小于corePoolSize？没满则创建一个新的工作线程来执行任务。已满则进入下个流程。
- 判断工作队列是否已满？没满则将新提交的任务添加在工作队列，等待执行。已满则进入下个流程。
- 判断整个线程池是否已满，即已创建线程数是否小于maximumPoolSize？没满则创建一个新的工作线程来执行任务，已满则交给饱和（拒绝）策略来处理这个任务。

##### 线程池参数

-  **corePoolSize：核心线程数**,活跃线程数量
-  **maximumPoolSize：最大线程数**
-  keepAliveTime：空闲线程存活时间
-  unit：keepAliveTime的时间单位
-  workQueue：工作队列
-  threadFactory：线程工厂
-  **handler：拒绝策略**

##### 四种拒绝策略

1. 终止策略:直接抛异常
2. 调用者策略: 交给提交任务的线程执行
3. 丢弃最早未处理请求:工作队列poll,弹出队首线程
4. 丢弃策略:开摆,不处理



## 面试题

### volatile加在对象上的作用

对象的成员变量也会受到volatile的影响,对象的创建,初始化过程也能保证有序.

### synchronized 和 Lock的区别

存在层次上
synchronized: Java的关键字，在jvm层面上

Lock: 是一个接口

锁的释放
synchronized: 1、以获取锁的线程执行完同步代码，释放锁 2、线程执行发生异常，jvm会让线程释放锁

Lock: 在finally中必须释放锁，不然容易造成线程死锁

锁的获取
synchronized: 假设A线程获得锁，B线程等待。如果A线程阻塞，B线程会一直等待

Lock: 分情况而定，Lock有多个锁获取的方式，大致就是可以尝试获得锁，线程可以不用一直等待(可以通过tryLock判断有没有锁)

锁的释放（死锁产生）
synchronized: 在发生异常时候会自动释放占有的锁，因此不会出现死锁?

Lock: 发生异常时候，不会主动释放占有的锁，必须手动unlock来释放锁，可能引起死锁的发生

锁的状态
synchronized: 无法判断

Lock: 可以判断

锁的类型
synchronized: 可重入 不可中断 非公平

Lock: 可重入 可判断 可公平（两者皆可）

性能
synchronized: 少量同步

Lock: 大量同步

Lock可以提高多个线程进行读操作的效率。（可以通过readwritelock实现读写分离）
在资源竞争不是很激烈的情况下，Synchronized的性能要优于ReetrantLock，但是在资源竞争很激烈的情况下，Synchronized的性能会下降几十倍，但是ReetrantLock的性能能维持常态；

调度
synchronized: 使用Object对象本身的wait 、notify、notifyAll调度机制

Lock: 可以使用Condition进行线程之间的调度

用法
synchronized: 在需要同步的对象中加入此控制，synchronized可以加在方法上，也可以加在特定代码块中，括号中表示需要锁的对象。

Lock: 一般使用ReentrantLock类做为锁。在加锁和解锁处需要通过lock()和unlock()显示指出。所以一般会在finally块中写unlock()以防死锁。

底层实现
synchronized: 底层使用指令码方式来控制锁的，映射成字节码指令就是增加来两个指令：monitorenter和monitorexit。当线程执行遇到monitorenter指令时会尝试获取内置锁，如果获取锁则锁计数器+1，如果没有获取锁则阻塞；当遇到monitorexit指令时锁计数器-1，如果计数器为0则释放锁。

Lock: 底层是CAS乐观锁，依赖AbstractQueuedSynchronizer类，把所有的请求线程构成一个CLH队列。而对该队列的操作均通过Lock-Free（CAS）操作。

