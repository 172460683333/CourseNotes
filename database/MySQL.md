# MySQL

## 事务

事务是用户定义的一系列操作SQL操作,要么同时成功,要么同时失败

### 性质

原子性:事务是原子操作

一致性:数据库总是从一个一致性的状态转换到另一个一致性的状态

隔离性:通常来说，一个事务所做的修改操作在提交事务之前，对于其他事务来说是不可见的。

持久性:一旦事务提交，则其所做的修改会永久保存到数据库。

### 并发事务的问题

脏读:读到了事务未提交的数据

不可重复读:两次同样的查询结果不同

幻读:读的时候没数据A,这时另一个事务插入了一条数据A,写的时候有数据发现A已存在,好像产生了幻觉

### 事务的隔离等级

read uncommitted 不能避免任何问题

read committed 可以避免脏读

repeatable read 可避免脏读和不可重复读

serializable 可避免脏读,不可重复读,幻读

## 存储引擎

存储引擎是存储数据,更新索引,更新/查询数据的实现方式,基于表存在,即不同表可以使用不同的引擎实现方式,因而也被称为表类型.MySQL默认使用InnoDB

InnoDB:高可用,高性能,支持事务,支持外键约束,使用行级锁,并发性能高,使用.idb文件储存表的结构,数据,索引

MyISAM:批量插入速度高,内存使用少

Memory:数据保存在memory里,访问速度快,可作临时储存和缓存,支持Hash索引

![image-20230206183742972](image/image-20230206183742972.png)

## 索引

索引是帮助MySQL高效获取数据的有序数据结构

优点:提高查询效率,缺点:占用空间,增加更新表时间

### 索引结构

取决于存储引擎

#### B+树索引

基于B+树的索引结构

m阶B树定义:

1、根结点至少有两个子女；

2、每个非根节点所包含的关键字个数 j 满足：┌m/2┐ - 1 <= j <= m - 1；

3、非根结点的度数之和正好是关键字总数加1，故**内部子树**个数 k 满足：┌m/2┐ <= k <= m ；

4、所有叶节点的高度相同.

树的高度:log┌m/2┐((N+1)/2 )+1,全文查找效率为O(logN)

B+树和B树的区别在于:

1. 数据只存在叶节点,非叶节点储存索引,因此树的高度会更小,减少查询时磁盘IO次数
2. 叶节点用单向链表连接,便于进行范围查询

MySQL对B+树做了优化,在相邻叶节点之间增加了双向指针,进一步提高了范围查询的效率

**Hash索引**

基于哈希表,效率很高但不能进行范围查询

使用hash算法,计算关键字的hash值,存储到哈希表,使用拉链法解决hash冲突.

**R-Tree空间索引**

MyISAM引入,主要用于地理空间数据

**Full-text全文索引**

建立倒排索引以快速匹配文档

### 索引分类

根据索引作用分类

- 主键索引,根据主键创建的索引,默认自动创建 primary
- 唯一索引,保证数据的唯一性unique
- 常规索引,加速数据搜素,可以有多个
- 全文索引,查找文本中的关键字fullText

根据InnoDB中索引的存储形式分类:

- 聚集索引(Cluster Index):数据和索引储存在一起,索引的叶节点保存行数据,有且只有一个
- 二级索引:数据与索引分开储存,索引结构的叶节点关联行数据对应的主键,可以有多个

聚集索引选取规则:

1. 有主键索引,选主键索引
2. 没有主键索引,选第一个唯一非空索引
3. 主键,唯一非空索引都没有,InnoDB会自动生成一个默认的rowid作为隐藏的聚集索引

建立索引后,MySQL会采用回表查询:即先到二级索引查询数据的主键值,再到聚集索引查询对应的行数据.

### SQL性能分析

- MySQL中查看每种SQL执行次数命令: show global status like 'com______';
- 慢查询日志:查看效率低的查询语句,在配置文件(Linux下的/etc/my.cnf)开启,使用cat localhost-slow.log命令查看日志信息
- show profile
  - set have_profiling=1开启show profile功能
  - show profiles查看每一条查询语句的执行时间
  - show profile for query [queryid]查看具体查询语句的耗时情况
- explain执行计划
  - 语法:在select前加上explain或者desc,返回执行计划表
  - id 查询执行顺序,id越大的越先执行,同id越上面的越先执行
  - type 表示连接类型**NULL**,**system**(整个表只有一行),**const**(主键/唯一索引,只有一个匹配行),**eq_ref**(主键/唯一索引,多个匹配行),**ref**(非唯一索引),range(**根据**给定索引范围查询),**index**(遍历索引全文),**all**(遍历整个表)
  - possible key:可能使用的索引关键字
  - key:实际用的索引关键字
  - key len:索引最大估计长度

### 索引使用原则

##### 索引使用注意

- 最左前缀法则
  - 如果索引了队列(联合索引),查询要从索引的最左列开始,并且不能跳过索引中的列,否则右边字段索引将失效.注意使用>或<会导致索引失效,而使用>=或<=不会.

- 不要做索引列运算(函数,like)
- 字符串要用单引号包围
- 不要做首部模糊查询.可以做尾部模糊匹配 
- or两侧的字段必须都建立索引
- MySQL优化器发现索引比全表扫描还慢时,索引会失效

##### SQL提示

在SQL语句中添加一些人为的提示来达到优化数据库的目的

use index 建议MySQL使用哪个索引

ignore index 忽略某个suoiyin

force index 强制使用哪个索引

##### 覆盖索引

查询语句只从索引中就能获得,尽量避免使用select *,减少回表查询

##### 前缀索引

字符串变量可能比较长,用字符串全文建立索引会浪费大量空间,因此可以使用字符串前缀建立索引.

索引选择性:不重复的索引值和数据总量的比值,索引选择性越大查询效率越高

##### 索引设计原则

![image-20230207193259662](image/image-20230207193259662.png)

## SQL优化

#### Insert优化

插入数据时建议:

- 批量插入
- 手动提交事务
- 主键顺序插入

- 海量数据插入,建议使用MySQL提供的load指令:

```mysql

#客户端连接数据库时,加上参数--local-infile
mysql --local-infile -u root -p
#设置全局变量local-infine为1,开启本地文件导入数据开关
set global local_infile=1;
#执行load指令将数据文件加载到数据库表结构中,此命令表示数据文件相邻元素用','分隔,行之间用'\n'分隔
load data local infile 'filepath' into table 'tb_name' fields terminated by ',' lines terminated by '\n';

```

#### 主键优化

InnoDB中,表数据是根据主键顺序组织存放的,这样的表称为索引组织表(IOT)

页分裂

InnoDB的数据使用分页储存,插入数据但页空间不足时,会开辟一个新页,并转移一半数据到新页中,并修改链表指针.乱序插入会导致频繁发生页分裂现象降低效率

页合并

InnoDB删除数据是对被删除数据进行标记,允许被申请使用,若一个分页中被标记数据超过阈值(默认50%),InnoDB会尝试与附近分页合并以优化空间.

主键设计原则

- 尽量减少主键的长度,以减少空间占用
- 尽量使用有序主键,避免使用身份证号,UUID做主键
- 尽量避免修改主键

#### order by优化

- 多字段排序要遵循最左原则
- 索引建立顺序尽量与查询顺序相同,减少filesort
- 可以适当增加排序缓冲区大小

#### count()

效率:count(*)>count(1)>count(主键/NOTNULL)>count(字段)

#### update()

更新时的筛选条件要选择有索引的字段,否则数据库的行锁将会升级成表锁
